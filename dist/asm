STACKSG SEGMENT STACK 'STACK'
	DW 120 DUP(?)	; RESERVE 240 BYTES FOR STACK
STACKSG ENDS

DATASG SEGMENT 'DATA'
	CR EQU 0DH				;CARRIAGE RETURN
	LF EQU 0AH				;LINE FEED
	TAB EQU 09H				;TAB
	
	RESERVE DW {res_size} DUP(0)
	ASSCII_NUM DB 30 DUP(?)	;THIS IS WHERE THE RESULT WILL STORE AS ASSCII CODE
	{strings}
DATASG ENDS

CODESG SEGMENT 'CODE'
	ASSUME SS: STACKSG , DS: DATASG , CS: CODESG
	
	MAIN PROC FAR
		
		MOV AX , DATASG
		MOV DS , AX

		
		{code_segment}

		MOV AX , 4C00H
		INT 21H
			
	MAIN ENDP
	
	{functions}
	
	CONVERT_ASSCII PROC NEAR
				
		;AT FIRST CHECK IF AX IS POSITIVE OR NEGETIVE
		TEST AX , 8000H					;CHECK THE LAST BIT . IF THATS 1 THEN AX IS NEG , OTHERWISE THATS POSITIVE
		MOV DI , 0						;AT FIRST SET OUR FLAG TO ZERO
		JZ AX_POSITIVE					;AX IS POSITIVE
		NEG AX							;CALCULATE NEGETIVE OF AX 
		MOV DI , 1						;DI INDICATES THAT AX IS NEG
		
	AX_POSITIVE :
		MOV CX , 10
		LEA SI , ASSCII_NUM
		ADD SI , 29						;MOVE TO THE LAST SPACE
		
		MOV BP , 0						;THIS IS THE COUNTER OF CHARS
		
		ASSCII_LOOP : MOV DX , 0
					  DIV CX 
					  OR DL , 30H		;MAKE REMINDER ASSCII
					  MOV [SI] , DL		;PUT ASSCII IN ASSCII_NUM
					  DEC SI
					  INC BP			;ADD ONE TO THE CHAR'S COUNTER
					  CMP AX , 0		;IF AX > 0 GOTO 
					  JA ASSCII_LOOP	;ASSCII_LOOP
		
		CMP DI , 0						;CHECK IF THAT WAS A NEGETIVE NUMBER
		JZ REST							;IF THATS NOT NEGETIVE GOTO REST
		MOV DL , '-'
		MOV [SI] , DL					;ADD A MINES SIGN TO THE STRING
		DEC SI
		INC BP
		
	REST :
		LEA DI , ASSCII_NUM
		
		;MOVE THE ASSCII CODE TO IT'S RIGHT PLCAE IN ASSCII_NUM
		ORDER_ASSCII : INC SI
					   MOV AL , BYTE PTR [SI] 
					   MOV BYTE PTR [DI] , AL
					   INC DI
					   DEC BP
					   CMP BP , 0
					   JA ORDER_ASSCII
		
		MOV CL , '$'		   
		MOV BYTE PTR [DI] , CL			;AT LAST PUT A DOLLOR SIGN AT THE END OF ASSCII_NUM
		
		RET
	CONVERT_ASSCII ENDP

	CLRSCR PROC NEAR
		MOV AX , 0600H
		MOV BH , 61H
		MOV CX , 0
		MOV DX , 184FH
		INT 10H
		RET
	CLRSCR ENDP

CODESG ENDS
	END	MAIN
