
te MACRO a1 , a2 

te ENDM


STACKSG SEGMENT STACK 'STACK'
	DW 120 DUP(?)	; RESERVE 240 BYTES FOR STACK
STACKSG ENDS

DATASG SEGMENT 'DATA'
	CR EQU 0DH				;CARRIAGE RETURN
	LF EQU 0AH				;LINE FEED
	TAB EQU 09H				;TAB
	
	RESERVE DW 12 DUP(0)
	ASSCII_NUM DB 30 DUP(?)	;THIS IS WHERE THE RESULT WILL STORE AS ASSCII CODE
	
	STRING1 DB 'alireza$'
	STRING0 DB 'from test$'

DATASG ENDS

CODESG SEGMENT 'CODE'
	ASSUME SS: STACKSG , DS: DATASG , CS: CODESG
	
	MAIN PROC FAR
		
		MOV AX , DATASG
		MOV DS , AX

		
		
		mov CX, 8
		mov AL, 11
		mul CL
		mov RESERVE + 2, AX
		mov CX, 3
		add CX, 5
		mov RESERVE + 4, CX
		mov CX, RESERVE + 4
		mov AL, BYTE PTR RESERVE + 2
		mul CL
		mov RESERVE + 6, AX
		mov CX, RESERVE + 6
		add CX, 10
		mov RESERVE + 8, CX
		mov AX, RESERVE + 8
		mov RESERVE + 0, AX
		mov BX, 2
		mov AX, 1
		cmp AX, BX
		jle labelmain22
		mov AX, 10
		mov RESERVE + 10, AX
		labelmain22:
		te 10 , STRING1
		labelmain24: 


		MOV AX , 4C00H
		INT 21H
			
	MAIN ENDP
	
	CONVERT_ASSCII PROC NEAR
				
		;AT FIRST CHECK IF AX IS POSITIVE OR NEGETIVE
		TEST AX , 8000H					;CHECK THE LAST BIT . IF THATS 1 THEN AX IS NEG , OTHERWISE THATS POSITIVE
		MOV DI , 0						;AT FIRST SET OUR FLAG TO ZERO
		JZ AX_POSITIVE					;AX IS POSITIVE
		NEG AX							;CALCULATE NEGETIVE OF AX 
		MOV DI , 1						;DI INDICATES THAT AX IS NEG
		
	AX_POSITIVE :
		MOV CX , 10
		LEA SI , ASSCII_NUM
		ADD SI , 29						;MOVE TO THE LAST SPACE
		
		MOV BP , 0						;THIS IS THE COUNTER OF CHARS
		
		ASSCII_LOOP : MOV DX , 0
					  DIV CX 
					  OR DL , 30H		;MAKE REMINDER ASSCII
					  MOV [SI] , DL		;PUT ASSCII IN ASSCII_NUM
					  DEC SI
					  INC BP			;ADD ONE TO THE CHAR'S COUNTER
					  CMP AX , 0		;IF AX > 0 GOTO 
					  JA ASSCII_LOOP	;ASSCII_LOOP
		
		CMP DI , 0						;CHECK IF THAT WAS A NEGETIVE NUMBER
		JZ REST							;IF THATS NOT NEGETIVE GOTO REST
		MOV DL , '-'
		MOV [SI] , DL					;ADD A MINES SIGN TO THE STRING
		DEC SI
		INC BP
		
	REST :
		LEA DI , ASSCII_NUM
		
		;MOVE THE ASSCII CODE TO IT'S RIGHT PLCAE IN ASSCII_NUM
		ORDER_ASSCII : INC SI
					   MOV AL , BYTE PTR [SI] 
					   MOV BYTE PTR [DI] , AL
					   INC DI
					   DEC BP
					   CMP BP , 0
					   JA ORDER_ASSCII
		
		MOV CL , '$'		   
		MOV BYTE PTR [DI] , CL			;AT LAST PUT A DOLLOR SIGN AT THE END OF ASSCII_NUM
		
		RET
	CONVERT_ASSCII ENDP

	CLRSCR PROC NEAR
		MOV AX , 0600H
		MOV BH , 61H
		MOV CX , 0
		MOV DX , 184FH
		INT 10H
		RET
	CLRSCR ENDP

CODESG ENDS
	END	MAIN